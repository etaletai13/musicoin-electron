{"version":3,"sources":["helpers/convertToIcns.js"],"names":["isOSX","helpers","tmp","setGracefulCleanup","PNG_TO_ICNS_BIN_PATH","path","join","__dirname","convertToIcns","pngSrc","icnsDest","callback","shell","exec","silent","exitCode","stdOut","stdError","includes","convertToIcnsTmp","tempIconDirObj","dirSync","unsafeCleanup","tempIconDirPath","name"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;;;IAEQA,K,GAAUC,iB,CAAVD,K;;AACRE,cAAIC,kBAAJ;;AAEA,IAAMC,uBAAuBC,eAAKC,IAAL,CAAUC,SAAV,EAAqB,OAArB,EAA8B,mBAA9B,CAA7B;;AAEA;;;;;;AAMA;;;;;;AAMA,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,QAA/B,EAAyCC,QAAzC,EAAmD;AACjD,MAAI,CAACX,OAAL,EAAc;AACZW,aAAS,+CAAT,EAA0DF,MAA1D;AACA;AACD;;AAEDG,oBAAMC,IAAN,CACG,GAAET,oBAAqB,IAAGK,MAAO,IAAGC,QAAS,EADhD,EAEE,EAAEI,QAAQ,IAAV,EAFF,EAGE,UAACC,QAAD,EAAWC,MAAX,EAAmBC,QAAnB,EAAgC;AAC9B,QAAID,OAAOE,QAAP,CAAgB,oBAAhB,KAAyCH,QAA7C,EAAuD;AACrD,UAAIA,QAAJ,EAAc;AACZJ,iBACE;AACEK,gBADF;AAEEC;AAFF,SADF,EAKER,MALF;AAOA;AACD;;AAEDE,eAASK,MAAT,EAAiBP,MAAjB;AACA;AACD;;AAEDE,aAAS,IAAT,EAAeD,QAAf;AACD,GArBH;AAuBD;;AAED;;;;;AAKA,SAASS,gBAAT,CAA0BV,MAA1B,EAAkCE,QAAlC,EAA4C;AAC1C,MAAMS,iBAAiBlB,cAAImB,OAAJ,CAAY,EAAEC,eAAe,IAAjB,EAAZ,CAAvB;AACA,MAAMC,kBAAkBH,eAAeI,IAAvC;AACAhB,gBAAcC,MAAd,EAAuB,GAAEc,eAAgB,YAAzC,EAAsDZ,QAAtD;AACD;;kBAEcQ,gB","file":"convertToIcns.js","sourcesContent":["import shell from 'shelljs';\nimport path from 'path';\nimport tmp from 'tmp';\nimport helpers from './helpers';\n\nconst { isOSX } = helpers;\ntmp.setGracefulCleanup();\n\nconst PNG_TO_ICNS_BIN_PATH = path.join(__dirname, '../..', 'bin/convertToIcns');\n\n/**\n * @callback pngToIcnsCallback\n * @param error\n * @param {string} icnsDest If error, will return the original png src\n */\n\n/**\n *\n * @param {string} pngSrc\n * @param {string} icnsDest\n * @param {pngToIcnsCallback} callback\n */\nfunction convertToIcns(pngSrc, icnsDest, callback) {\n  if (!isOSX()) {\n    callback('OSX is required to convert .png to .icns icon', pngSrc);\n    return;\n  }\n\n  shell.exec(\n    `${PNG_TO_ICNS_BIN_PATH} ${pngSrc} ${icnsDest}`,\n    { silent: true },\n    (exitCode, stdOut, stdError) => {\n      if (stdOut.includes('icon.iconset:error') || exitCode) {\n        if (exitCode) {\n          callback(\n            {\n              stdOut,\n              stdError,\n            },\n            pngSrc,\n          );\n          return;\n        }\n\n        callback(stdOut, pngSrc);\n        return;\n      }\n\n      callback(null, icnsDest);\n    },\n  );\n}\n\n/**\n * Converts the png to a temporary directory which will be cleaned up on process exit\n * @param {string} pngSrc\n * @param {pngToIcnsCallback} callback\n */\nfunction convertToIcnsTmp(pngSrc, callback) {\n  const tempIconDirObj = tmp.dirSync({ unsafeCleanup: true });\n  const tempIconDirPath = tempIconDirObj.name;\n  convertToIcns(pngSrc, `${tempIconDirPath}/icon.icns`, callback);\n}\n\nexport default convertToIcnsTmp;\n"]}